# 如何用舞蹈鏈（Dancing Links）算法求解數獨

https://www.cnblogs.com/grenet/p/3163550.html

## 步驟

1. 把數獨問題轉換為精確覆蓋問題
2. 設計出數據矩陣
3. 用舞蹈鏈（Dancing Links）算法求解該精確覆蓋問題
4. 把該精確覆蓋問題的解轉換為數獨的解

## 限制條件

1. 每個格子只能填一個數字
2. 每行每個數字都得填一遍 (橫的)
3. 每列每個數字都得填一遍 (直的)
4. 每宮每個數字都得填一遍 (方格)

約束條件 1：row * board_size + col

```
第 1 列定義成：（1，1）填了一個數字
第 2 列定義成：（1，2）填了一個數字
……
第 9 列定義成：（1，9）填了一個數字
第 10 列定義成：（2，1）填了一個數字
……
第 18 列定義成：（2，9）填了一個數字
……
第 81 列定義成：（9，9）填了一個數字
```

約束條件 2：board_size * board_size + row * board_size + (num - 1)

```
第 82 列定義成：在第 1 行填了數字 1
第 83 列定義成：在第 1 行填了數字 2
……
第 90 列定義成：在第 1 行填了數字 9
第 91 列定義成：在第 2 行填了數字 1
……
第 99 列定義成：在第 2 行填了數字 9
……
第 162 列定義成：在第 9 行填了數字 9
```

約束條件 3：2 * board_size * board_size + col * board_size + (num - 1)

```
第 163 列定義成：在第 1 列填了數字 1
第 164 列定義成：在第 1 列填了數字 2
……
第 171 列定義成：在第 1 列填了數字 9
第 172 列定義成：在第 2 列填了數字 1
……
第 180 列定義成：在第 2 列填了數字 9
……
第 243 列定義成：在第 9 列填了數字 9
```

約束條件 4：3 * board_size * board_size + 第幾宮 * board_size + (num - 1)

```
第 244 列定義成：在第 1 宮填了數字 1
第 245 列定義成：在第 1 宮填了數字 2
……
第 252 列定義成：在第 1 宮填了數字 9
第 253 列定義成：在第 2 宮填了數字 1
……
第 261 列定義成：在第 2 宮填了數字 9
……
第 324 列定義成：在第 9 宮填了數字 9
```

## 有數字的格子

（4，2）中填的是 7，解釋成 4 個約束條件

1. 在（4，2）中填了一個數字。
2. 在第 4 行填了數字 7
3. 在第 2 列填了數字 7
4. 在第 4 宮填了數字 7

`於是，（4，2）中填的是 7，轉成矩陣的一行就是，第 29、115、178、277 (index 由 1 開始，和程式有所不同) 列是 1，其餘列是 0。`

## 沒數字的格子

把（5，8）中沒有數字轉換成
1. （5，8）中填的是 1，轉成矩陣的一行就是，第 44、118、226、289 列是 1，其餘列是 0。
2. （5，8）中填的是 2，轉成矩陣的一行就是，第 44、119、227、290 列是 1，其餘列是 0。
3. （5，8）中填的是 3，轉成矩陣的一行就是，第 44、120、228、291 列是 1，其餘列是 0。
4. （5，8）中填的是 4，轉成矩陣的一行就是，第 44、121、229、292 列是 1，其餘列是 0。
5. （5，8）中填的是 5，轉成矩陣的一行就是，第 44、122、230、293 列是 1，其餘列是 0。
6. （5，8）中填的是 6，轉成矩陣的一行就是，第 44、123、231、294 列是 1，其餘列是 0。
7. （5，8）中填的是 7，轉成矩陣的一行就是，第 44、124、232、295 列是 1，其餘列是 0。
8. （5，8）中填的是 8，轉成矩陣的一行就是，第 44、125、233、296 列是 1，其餘列是 0。
9. （5，8）中填的是 9，轉成矩陣的一行就是，第 44、126、234、297 列是 1，其餘列是 0。

把這 9 行插入到矩陣中。**由於這 9 行的第 44 列都是 1（不會有其他行的 44 列會是 1）**，也就是說**這 9 行中必只有 1 行（有且只有 1 行）選中（精確覆蓋問題的定義，每列只能有 1 個 1）**，是最後解的一部分。這就保證了最後解在（5，8）中只有 1 個數字。

## 改進

1. 先遍歷數獨的格子，把那些有數字的格子轉換為行，插入到矩陣中。
2. 在遍歷沒有數字的格子，轉換為若干行（1 個格子 9 行）插入到矩陣中。在插入到矩陣的時候，判斷新插入的行和第 1 步中的某些行是否相衝；若是個無效行，沒有必要插入到矩陣中。

經過這個優化，能大大減少矩陣的規模（列不變，行減少了不少）

# Pseudo code

http://blog.gssxgss.me/use-dlx-to-solve-sudoku-1/

## 搜索

```
如果 R[h] = h ，打印當前的解（見下）並且返回。
否則選擇一個列對象 c（見下）。
覆蓋列 c（見下）。
對於每個 r ← D[c]，D[D[c]]，……，當 r != c，
　　設置 Ok <- r；
　　對於每個 j ← R[r]，R[R[r]]，……，當 j != r，
　　　　覆蓋列 j（見下）；
　　search(k + 1)；
　　設置 r ← Ok 且 c ← C[r]；
　　對於每個 j ← L[r]，L[L[r]]，……，當 j != r，
　　　　取消列 j 的覆蓋（見下）。
取消列 c 的覆蓋（見下）並且返回。
```

## 選擇列

```
對於每個 j ← R[h]，R[R[h]]，……，當 j != h，
　　如果 S[j] < s 設置 c ← j 且 s ← S[h]。
```

## 覆蓋

```
設置 L[R[c]] ← L[c] 且 R[L[c]] ← R[c]。
對於每個 i ← D[c]，D[D[c]]，……，當 i != c，
　　對於每個 j ← R[i]，R[R{i]]，……，當 j != i，
　　　　設置 U[D[j]] ← U[j]，D[U[j]] ← D[j]，
　　　　並且設置 S[C[j]] ← S[C[j]]-1。
```

## 取消覆蓋

```
對於每個 i ← U[c]，U[U[c]]，……，當 j != i，
　　對於每個 j ← L[i]，L[L[i]]，……，當 j != i，
　　　　設置  S[C[j]] ← S[C[j]]+1，
　　　　並且設置 U[D[j]] ← j，D[U[j]] ← j。
設置 L[R[c]] ← c 且 R[L[c]] ← c。
```

# Reference Links

## Dancing Links and Knuth's Algorithm X (DLX)

1. https://en.wikipedia.org/wiki/Exact_cover
2. https://en.wikipedia.org/wiki/Knuth%27s_Algorithm_X
3. http://www.cnblogs.com/grenet/p/3145800.html

## Sudoku in Dancing Links

1. https://www.cnblogs.com/grenet/p/3163550.html
2. https://www.ocf.berkeley.edu/~jchu/publicportal/sudoku/sudoku.paper.html

## Source

1. https://rafal.io/posts/solving-sudoku-with-dancing-links.html
2. https://www.baeldung.com/java-sudoku

Skip filled cell

1. https://blog.csdn.net/zjx409/article/details/41846077
2. https://github.com/ppwwyyxx/sudoku/tree/master/java

## Other reference

+ https://www.kevinhooke.com/2019/01/22/revisiting-donald-knuths-algorithm-x-and-dancing-links-to-solve-sudoku-puzzles/
